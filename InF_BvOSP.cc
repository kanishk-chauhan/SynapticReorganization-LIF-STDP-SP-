/*                  
 *        File: InF_BvOSP
 *      Author: Kanishk Chauhan
 *        Date: Dec 20, 2023
 * Description: This code uses Butz and van Ooyen's SP method. Multiple contacts are permitted.
 */

# include <iostream>
# include <algorithm>
# include <iomanip>
# include <sstream>
# include <cmath>
# include <cstdlib>
# include <fstream> 
# include <vector>
# include <complex>
# include <random>

using namespace std;

// ----------------------TAKEN FROM NUMERICAL RECIPES FOR GENERATING RANDOM NUMBERS--------------------------------
struct Ran {
    typedef unsigned int long long Ullong; 
    typedef unsigned int Uint;
    Ullong u,v,w;
    Ran(Ullong j) : v(4101842887655102017LL), w(1) {
    u = j ^ v; int64();
    v = u; int64();
    w = v; int64();
}
inline Ullong int64() {
    u = u * 2862933555777941757LL + 7046029254386353087LL;
    v ^= v >> 17; v ^= v << 31; v ^= v >> 8;
    w = 4294957665U*(w & 0xffffffff) + (w >> 32);
    Ullong x = u ^ (u << 21); x ^= x >> 35; x ^= x << 4;
    return (x + v) ^ w;
}
inline double doub() { return 5.42101086242752217E-20 * int64(); } //Returns a double-type random number between 0 and 1
inline Uint int32() { return (Uint)int64(); } //Return 32-bit random integer.
};

struct Normaldev_BM : Ran {
    typedef double Doub;
    typedef unsigned int long long Ullong;
    Doub mu,sig;
    Doub storedval;
    Normaldev_BM(Doub mmu, Doub ssig, Ullong i) // constructor
    : Ran(i), mu(mmu), sig(ssig), storedval(0.) {}

    Doub dev() {
        Doub v1,v2,rsq,fac;
        if (storedval == 0.) {
            do {
                v1=2.0*doub()-1.0;
                v2=2.0*doub()-1.0;
                rsq=v1*v1+v2*v2;
            } while (rsq >= 1.0 || rsq == 0.0);
            fac=sqrt(-2.0*log(rsq)/rsq);
            storedval = v1*fac;
            return mu + sig*v2*fac;
        } else {
            fac = storedval;
            storedval = 0.;
            return mu + sig*fac;
        }
    }
};
// ------------------------------------------------------------------------------------------------------------------

// ============================== THE FUNCTIONS =============================
// the function to generate Random Connectivity by Renyi-Erdos method
vector<vector<double> > Adjacency_Matrix(int N, double p);
// the function to generate a the adjacency matrix with distance dependent contact probability  
vector<vector<double> > Dist_Dep_Adjacency_Matrix(int N, double p, vector<vector<double> > Zd);

// the function to update the neurons' membrane potential
void InF(double dt, int itrain, double gleak[], double gsyn[], double gnoise[], double noise[], double V[], double Vth[], double Istim[], double inlinks[], double train_pre[], 
                double tdelay, double Vrest, double Vsyn, double Vth_rest, double Tsyn, double Tth, double C0, double k, double knoise, int N, 
                vector<vector<double> > &A, vector<vector<double> > &Wlinks, vector<vector<int> > &preLinks);

// the function to implement the STDP rule with TRACE AND TRAIN METHOD
void STDP1(int N, double dt, double ed, double ep, double train_pre[], double train_post[], double trace_pre[], double trace_post[], double inlinks[], vector<vector<double> > &Wlinks, vector<vector<int> > &preLinks);

// the SP function with Butz2013 method
void ButzSP(Ran &random, vector<vector<double> > &Wlinks, vector<vector<double> > &A, vector<vector<double> > Zd, double fT, double fi[], double inlinks[], double outlinks[],
             double Tw, double sprouting_rate, double Pw, int &pruned, int &added, double Ax[], double Ax_vac[], double delAx[], double Dn[],
             double Dn_vac[], double delDn[], vector<vector<int> > &preLinks, vector<vector<int> > &postLinks, double Wmin);

const int m = 20;
const int N = m*m; // number of neurons

int main(int argc, char* argv[]){

    // for random numbers
    Ran random(100); //100 is given as a seed for random number generator struct. Now random.doub() would generate a uniform random number between 0 and 1
    Normaldev_BM normal_random(0,1,100); // mean = 0, s.d. = 1, and seed = 100. Now normal_random.dev() would generate a normally distributed random number generated by B-M method

    double Tw,tp,tr,td,t,dt,dt_inv,msecs,tmax,pi,d_theta,d_theta_wrapped,ed,ep,epsilon,sum,a,f0,gamma,D,hours,w_sd,w0,W_mean,W_sd,dn,nl,in_con,out_con,n_con_init,knoise,fnoise,Tth,Tsyn,k,Vsyn,Vrest,Vth_rest,C0,Cstd,Vreset,Vspike,Tspike,Vth_spike,tdelay,Tslow;
    double fisum,isi_mean,isi_sum,rnd, current_time,Avg_W,indeg,outdeg,order_par,rand_num,lamda,Pa,I,p,beta_min,beta_max,n_con_max,n_con_min,n_con_p,Fs,e,ki0,ki0N,ki0p,ki0Np,eta,tou_st,stim_sigma,b,H,sum_loc,ee,d0,lifetime_hole,P0,SI,Wmin,dd,L,dc,rtime0,fi_mean,fi_sd,spk;
    double gleak0, gleak_std, fT, fstd, fmeanw, odpr, sumcos,sumsin, hr, un, vn, dst, Pw, Ph, fi_mean0, Avg_W0, fi_err, Avg_Werr, max_err;
    int nf_updt,nspktm,ispktm,nt,ntrain,itrain,n_noise_spikes,i_noise_spike,num_itrn,pos,pos1,pos2,pre,np,pruned,added,index,Na,a_init_pos,a_final_pos,part,rtime,stime,pstime,stim_width,frac,osc_index,win_size,nspk,nlo,flg,sp_it,nSPupdate,iSPupdate;
    double V[N], V0[N], Vth[N], C[N], gleak[N], theta[N], fi[N], fiw[N], cpl_term[N], theta_new[N], gnoise[N], Istim[N], Inoise[N], noise[N], gsyn[N], flag[N], trace_pre[N];
    double trace_post[N], noise_train_array[N], inlinks[N], outlinks[N], osc_indices[N], avgW[N], spikeTimes[N], spikeTimes0[N], train_pre[N], train_post[N], phi[N];
    double xi[N], yi[N];
    double Ax[N], Ax_vac[N], delAx[N], Dn[N], Dn_vac[N], delDn[N]; // for axonal and dendritic elements
    int counts[N], counts2[N];
    double c1,f1,f2,lambda_h,lambda_w,delta_f,nu,p0,sprouting_rate; // variables for structural plasticity

    // taking command line inputs 
    a = atof(argv[1]); // the asymmetry paramter for STDP
    W_mean = atof(argv[2]); // the mean initial synaptic weight of the network
    p = atof(argv[3]); // the initial average NDD

    // the files to store all the data
    char* filename1 = new char[500];
    char* filename2 = new char[500];
    char* filename3 = new char[500];
    char* filename4 = new char[500];

    sprintf(filename1,"STDP+ButzSP(a=%.1f,Wmean=%.1f,beta=%.3f)fT4.5.dat",a,W_mean,p);
    sprintf(filename2,"W_STDP+ButzSP(a=%.1f,Wmean=%.1f,beta=%.3f)fT4.5.dat",a,W_mean,p);
    sprintf(filename3,"A_STDP+ButzSP(a=%.1f,Wmean=%.1f,beta=%.3f)fT4.5.dat",a,W_mean,p);
    sprintf(filename4,"FR_STDP+ButzSP(a=%.1f,Wmean=%.1f,beta=%.3f)fT4.5.dat",a,W_mean,p);
    
    ofstream data(filename1);
    ofstream W_file(filename2);
    ofstream A_file(filename3);
    ofstream FR_file(filename4);
    
    // time stuff
    nSPupdate = 2000; // number of maximum SP updates allowed. 
    hours = nSPupdate*20.0/60.0; // it is large enough to accomodate nSPupdate windows of arbitary duration from 1 to 51 minutes each
    msecs = 3600e3; // number of miliseconds in 1 hour
    dt = 0.5; // in ms
    dt_inv = 1/dt; // the height of a spike
    rtime0 = 600e3; // the relaxtion time without plasticity (in ms)
    rtime = hours*msecs; // relax time with plasticity (in ms)
    Tw = 60e3; // window size in ms- the STRUCTURAL UPDATE INTERVAL
    nt = Tw/dt; // number of time steps in one Tw long window
    
    // connectivity constraints
    fT = 4.5; // Target firing rate in Hz
    f0 = 3.0; // network-averaged firing rate in units of spike/time
    fstd = 0.5; // allowed standard deviaiton in the uncoupled neurons' firing rates
    d0 = 1.0/(N-1); // for stimulus spatial profile
    
    // parameter values
    k = 8.0; // in mS/cm^2
    C0 = 3; // mean neuron membrane capacitance in units of micro F/cm^2
    gleak0 = (f0 - 0.9177303000633497)/125.6691632725962;  // these 'm' and 'c' for fr=m*gleak+c will change with noise intensity.
    gleak_std = fstd/125.6691632725962;
    Vrest = -38; // resting potential in mV
    Vreset = -67; // in mV
    Vsyn = 0; // in mV
    Vth_spike = 0; // in mV
    Vth_rest = -40; // in mV
    Vspike = 20; // in mV
    Tspike = 1.0; // in ms
    Tsyn = 1.0; // in ms
    Tth = 5.0; // in ms
    tdelay = 3.; // in ms
    Tslow = 30e3; // in ms
    knoise = 0.06; // in mS/cm^2
    fnoise = 20; // in Hz
    tr = 4.0; // scales the depression time constant wrt potentiation
    tp = 10.0; // in ms
    td = tr*tp;
    eta = 0.02; // weight change quantum
    ep = eta; 
    ed = a*eta/tr; // As in Kromer and Tass's PRR 2020 Paper (Long-lasting desynchronization by decoupling stimulus)
    W_sd = 0.05; // standard deviation of weights
    pi = 4*atan(1);
    max_err = 1e-3;
    
    // Structural plasticity parameters
    Wmin = 0.001; // for weight dependent pruning
    delta_f = 1.0;
    f1 = fT - delta_f/2;
    f2 = fT + delta_f/2;
    c1 = exp(-1.0/Wmin);
    p0 = 0.01; // fraction of homeostatic addition and pruning probability when a neuron's firing rate equals the target rate
    nu = delta_f/(2*log((1-p0)/p0));
    Pw = 0.01;
    sprouting_rate = 1e-5;

    // positions of and distance between neurons
    hr = 1.0/(m-1); // m divisions in 1.0mm
    dst = 0.5; // in mm
    vector<double> zerodis(N,0);
    vector<vector<double> > dij(N,zerodis);
    vector<vector<double> > Zd(N,zerodis);
    for (int i = 0; i < N; i++){
        un = random.doub(); vn = random.doub();
        xi[i] = fmod((i+0.5),m)*hr + hr/10.0 * sqrt(-2*log(un)) * cos(2*pi*vn); // x-position of the i-th neuron
        yi[i] = (0.5+int(i/m))*hr + hr/10.0 * sqrt(-2*log(un)) * sin(2*pi*vn); // y-position of the i-th neuron
    }
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            dij[i][j] = sqrt(pow((xi[i]-xi[j]),2)+pow((yi[i]-yi[j]),2));
            Zd[i][j] = exp(-dij[i][j]/dst);
        }
    }

    // the 2D 'spike train' array- rows= neurons, columns= corresponding spike trains
    ntrain = int(tdelay/dt); if(ntrain == 0) ntrain = 1; // number of points we need in the spike trains of all neurons
    vector<double> seero(ntrain,0);
    vector<vector<double> > train(N,seero);

    // the 2D 'inter-spike interval' array- rows= neurons, columns= corresponding inter-spike intervals
    vector<double> zeroisi(nt,0);
    vector<vector<double> > isi(N,zeroisi);

    // the 'Adjacency matrix' and its copy for correct structural updates
    vector<double> zeero(N,0);
    vector<vector<double> > A(N,zeero);
    A = Dist_Dep_Adjacency_Matrix(N,p,Zd); // the initial adjacency matrix
    vector<vector<double> > A0 = A; 

    // recording the initial Adjacency Matrix
    for(int ii = 0; ii < N; ii++){
        for(int jj = 0; jj < N; jj++){
            A_file << A[ii][jj] << "  ";
        }
        A_file << endl;
    }

    // ======================================================= INITIALIZING =======================================================
    // initial values of Capacitance, membrane potential, threshold, etc
    for(int i = 0; i < N; i++){
        gleak[i] = gleak0+gleak_std*normal_random.dev();  
        V[i] = Vreset + (Vrest-Vreset)*random.doub();//cout << V[i] << " " ;// -67 + (-38+67)*random(between 0 and 1)
        Vth[i] = Vth_rest;
        gsyn[i] = 0;
        gnoise[i] = 0;
        flag[i] = 1;
        spikeTimes[i] = 0;
        train_pre[i] = train_post[i] = trace_pre[i] = trace_post[i] = 0;
        osc_indices[i] = i;
        Istim[i] = 0;
        Ax_vac[i] = 0;
        delAx[i] = 0;
        Dn_vac[i] = 0;
        delDn[i] = 0;
        fi[i] = 0;
        counts2[i] = 0; counts[i] = 0;
    }

    // Information about the # of pre and post synaptic partners
    for(int ii = 0; ii < N; ii++){
        nl = 0; nlo = 0;
        for(int jj = 0; jj < N; jj++){ // 'A' only has 0s and 1s in the beginning because we assume that the network begins with single synaptic contacts between any pair of neurons
            if (A[ii][jj] == 1) nl++;
            if (A[jj][ii] == 1) nlo++;
        }
        outlinks[ii] = nlo;
        inlinks[ii] = nl;
    }

    // Initializing the matrices that will store the information about the pre and post synaptic neurons' indices
    vector<vector<int> > preLinks(N); // the matrix to store indices of the presynaptic partners
    vector<vector<int> > postLinks(N); // the matrix to store indices of the postsynaptic partners
    vector<vector<double> > Wlinks(N); 

    for(int ii = 0; ii < N; ii++){ // this puts empty columns in the 2D 'links' matrices. The # of columns is equal to the number of partners
        nl = inlinks[ii]; nlo = outlinks[ii];
        preLinks[ii] = vector<int> (nl);
        Wlinks[ii] = vector<double> (nl);
        postLinks[ii] = vector<int> (nlo);
    }

    // Initial information about the presynaptic and postsynaptic partners (nl and nlo in this loop are the same as above. I keep them here for no reason)
    in_con = 0; out_con = 0;
    for(int ii = 0; ii < N; ii++){
        nl = 0; pos1 = 0; pos2 = 0; nlo = 0;
        for(int jj = 0; jj < N; jj++){
            if (A[ii][jj] == 1){ // 'A' only has 0s and 1s in the beginning because we assume that the network begins with single synaptic contacts between any pair of neurons
                preLinks[ii][pos1] = jj;
                nl++;
                pos1++;
            }
            if (A[jj][ii] == 1) {
                postLinks[ii][pos2] = jj;
                nlo++;
                pos2++;
            }
        }
        outlinks[ii] = nlo;
        inlinks[ii] = nl;
        Ax[ii] = nlo; // Since initially there are no free axonal elements, the #of axonal elements= #of postsynaptic partners
        Dn[ii] = nl; // Since initially there are no free dendritic elements, the #of dendritic elements= #of presynaptic partners
        in_con += nl;
        out_con += nlo;
    }
    n_con_init = in_con; // this should not be updated after this step
    indeg = in_con/N/(N-1); // incoming node degree density
    outdeg = out_con/N/(N-1); // outgoing node degree density : NOTE THAT indeg = outdeg at any point in time. So, we don't really need two separate variables
    
    // initial values of Wij (elements of the weight matrix)
    for (int ii = 0; ii < N; ii++){
        nl = inlinks[ii]; // the # of presynaptic partners of i-th neuron
        for (int jj = 0; jj < nl; jj++) Wlinks[ii][jj] = W_mean + W_sd*(2*random.doub()-1); // random values-> W_mean +- W_sd 
    }
     
    // for the 2D 'noise spike time intervals' array- rows= neurons, columns= corresponding noise inter-spike intervals
    n_noise_spikes = int(10*Tw/1000*fnoise); 

    // calculating the INITIAL mean synaptic weights
    sum = 0; in_con = 0;
    for(int ii = 0; ii < N; ii++){
        nl = inlinks[ii]; sum_loc = 0; 
        for(int jj = 0; jj < nl; jj++) sum_loc += Wlinks[ii][jj];
        in_con += nl;
        sum += sum_loc;
        avgW[ii] = sum_loc/nl;
    }
    Avg_W = sum/in_con;

//*********************************************SOME TIME WITHOUT PLASTICITY**********************************************//
    num_itrn = rtime0/Tw; //cout << "nt" << num_itrn << endl;
    for (int i = 0; i < num_itrn; i++){
        
        k = 0.0; // out of 'num_itrn' iterations without plasticity, first half are executed without coupling to let the neurons reach their stable natural firing rate
        if(i >= num_itrn/2) k = 8.0;

        for(int ii = 0; ii < N; ii++) counts[ii] = 0;
        odpr = 0;

        // the 2D 'noise train' array- rows= neurons, columns= corresponding noise spike trains
        vector<double> zeronoise(nt,0);
        vector<vector<double> > noise_train(N,zeronoise);
        // preparing the noise spike train using the exponentially distributed random inter-spike intervals
        for (int ii = 0; ii < N; ii++){ // for each neuron
            i_noise_spike = 0; // index of spike in the noise spike train
            for (int jj = 0; jj < n_noise_spikes; jj++){ 
                rnd = -log(random.doub())/fnoise; // exp_rnd(rnd_generator);
                i_noise_spike += int(rnd*1000/dt);
                if (i_noise_spike >= nt) break;
                noise_train[ii][i_noise_spike] = dt_inv;
            }
        }
        
        // for each time step of the iteration
        for (int j = 0; j < nt; j++){
            current_time = i*Tw + j*dt;
            itrain = int(j%ntrain); // the index for time 'tdelay' before the current time 

            for (int ii = 0; ii < N; ii++){ // for each neuron
                train_pre[ii] = train[ii][itrain]; // delayed spike train
                trace_pre[ii] = trace_pre[ii] + dt*(-trace_pre[ii]/tp + train_pre[ii]); // updating the presynaptic trace with the spike train 'tdelay' before the current time
            }

            // integrating the Integrate and Fire model equations
            for (int ii = 0; ii < N; ii++){
                V0[ii] = V[ii];
                noise[ii] = noise_train[ii][j];
            }
            InF(dt,itrain,gleak,gsyn,gnoise,noise,V,Vth,Istim,inlinks,train_pre,tdelay,Vrest,Vsyn,Vth_rest,Tsyn,Tth,C0,k,knoise,N,A,Wlinks,preLinks);
            
            // discriminating the spikes
            for (int ii = 0; ii < N; ii++){ // for each neuron
                train[ii][itrain] = 0;  // the train gets updated in this loop. Upto the step before this, the train is from 'tdelay' before the current time
                if (V[ii] >= Vth[ii] && flag[ii] == 1){
                    spikeTimes0[ii] = spikeTimes[ii];
                    spikeTimes[ii] = current_time;
                    isi[ii][counts[ii]] = spikeTimes[ii] - spikeTimes0[ii];
                    counts[ii] += 1; counts2[ii] += 1;
                    train[ii][itrain] = dt_inv;
                    Vth[ii] = Vth_spike;
                    V[ii] = Vspike;
                    flag[ii] = 0; 
                }
                if (flag[ii] == 0){
                    if (j < (spikeTimes[ii] - i*Tw + Tspike)/dt){ // generating a rectangular spike of width Tspike
                        V[ii] = Vspike; 
                        Vth[ii] = Vth_spike;
                    }
                    else{
                        V[ii] = Vreset;
                        flag[ii] = 1;
                    }
                }
            }
            
            // postsynaptic train and trace
            for (int ii = 0; ii < N; ii++){ // for each neuron
                train_post[ii] = train[ii][itrain]; // current (non-delayed) spike train for postsynaptic neuron
                trace_post[ii] = trace_post[ii] + dt*(-trace_post[ii]/td + train_post[ii]); // updating the postsynaptic trace with the spike train at the current time
            }

            // the firing rate
            for (int ii = 0; ii < N; ii++){
                fi[ii] += dt/Tslow * (-fi[ii] + train_post[ii]*1e3);
            }

            // order parameter
            if (i > 0){
                sumsin = 0; sumcos = 0;
                for (int ii = 0; ii < N; ii++){
                    phi[ii] = 2*pi*((current_time - spikeTimes0[ii])/(spikeTimes[ii] - spikeTimes0[ii]) + counts2[ii]);
                    sumcos += cos(phi[ii]); sumsin += sin(phi[ii]);
                }
                odpr += sqrt(pow((sumcos/N),2) + pow((sumsin/N),2));
            }
        }
        odpr = odpr/nt; // time-averaging the order paramter

        fi_mean = 0;
        for (int ii = 0; ii < N; ii++) fi_mean += fi[ii]/N; // mean firing rate

        // calculating the mean of the synaptic weights and node degree
        sum = 0; in_con = 0;
        for(int ii = 0; ii < N; ii++){
            nl = inlinks[ii]; sum_loc = 0; 
            for(int jj = 0; jj < nl; jj++) sum_loc += Wlinks[ii][jj];
            in_con += nl;
            sum += sum_loc;
            avgW[ii] = sum_loc/nl;
        }
        Avg_W = sum/in_con;
        indeg = in_con/N/(N-1);

        // recording the firing rates
        for(int ii = 0; ii < N; ii++){
            FR_file << fi[ii] << "  ";
        }
        FR_file << endl;

        data << left << setw(15) << odpr << left << setw(15) << fi_mean << left << setw(15) << Avg_W << left << setw(15) << indeg << left << setw(15) << pruned << left << setw(15) << added<< left << setw(15) << 0 << endl;      
        cout << "Without plasticity: " << odpr << "  " << fi_mean << "   " << Avg_W << "   " << indeg << "   " << pruned << "  " << added << endl;  
    }
    
//********************************************* transition to steady state with STDP and SP************************************************//
    num_itrn = rtime/Tw; //cout << "num_itrn  " << num_itrn << endl;
    iSPupdate = 0;
    k = 8.0;
    flg = 2;
    int i = 0;
    while (iSPupdate < nSPupdate) { 
        pruned = 0;
        added = 0;
        for(int ii = 0; ii < N; ii++) counts[ii] = 0;
        odpr = 0;

        // the 2D 'noise train' array- rows= neurons, columns= corresponding noise spike trains
        vector<double> zeronoise(nt,0);
        vector<vector<double> > noise_train(N,zeronoise);
        // preparing the noise spike train using the exponentially distributed random inter-spike intervals
        for (int ii = 0; ii < N; ii++){ // for each neuron
            i_noise_spike = 0; // index of spike in the noise spike train
            for (int jj = 0; jj < n_noise_spikes; jj++){ 
                rnd = -log(random.doub())/fnoise; // exp_rnd(rnd_generator);
                i_noise_spike += int(rnd*1000/dt);
                if (i_noise_spike >= nt) break;
                noise_train[ii][i_noise_spike] = dt_inv;
            }
        }
        
        // for each time step of the iteration
        for (int j = 0; j < nt; j++){
            current_time = rtime0 + i*Tw + j*dt;
            itrain = int(j%ntrain); // the index for time 'tdelay' before the current time 

            for (int ii = 0; ii < N; ii++){ // for each neuron
                train_pre[ii] = train[ii][itrain]; // delayed spike train
                trace_pre[ii] = trace_pre[ii] + dt*(-trace_pre[ii]/tp + train_pre[ii]); // updating the presynaptic trace with the spike train 'tdelay' before the current time
            }

            // integrating the Integrate and Fire model equations
            for (int ii = 0; ii < N; ii++){
                V0[ii] = V[ii];
                noise[ii] = noise_train[ii][j];
            }
            
            InF(dt,itrain,gleak,gsyn,gnoise,noise,V,Vth,Istim,inlinks,train_pre,tdelay,Vrest,Vsyn,Vth_rest,Tsyn,Tth,C0,k,knoise,N,A,Wlinks,preLinks);       
            
            // discriminating the spikes
            for (int ii = 0; ii < N; ii++){ // for each neuron
                train[ii][itrain] = 0;  // the train gets updated in this loop. Upto the step before this, the train is from 'tdelay' before the current time
                if (V[ii] >= Vth[ii] && flag[ii] == 1){
                    spikeTimes0[ii] = spikeTimes[ii];
                    spikeTimes[ii] = current_time;
                    isi[ii][counts[ii]] = spikeTimes[ii] - spikeTimes0[ii];
                    counts[ii] += 1; counts2[ii] += 1;
                    train[ii][itrain] = dt_inv;
                    Vth[ii] = Vth_spike;
                    V[ii] = Vspike;
                    flag[ii] = 0;
                }
                if (flag[ii] == 0){
                    if (j < (spikeTimes[ii] - rtime0 - i*Tw + Tspike)/dt){ // generating a rectangular spike of width Tspike
                        V[ii] = Vspike; 
                        Vth[ii] = Vth_spike;
                    }
                    else{
                        V[ii] = Vreset;
                        flag[ii] = 1;
                    }
                }
            }
            
            // postsynaptic train and trace
            for (int ii = 0; ii < N; ii++){ // for each neuron
                train_post[ii] = train[ii][itrain]; // current (non-delayed) spike train for postsynaptic neuron
                trace_post[ii] = trace_post[ii] + dt*(-trace_post[ii]/td + train_post[ii]); // updating the postsynaptic trace with the spike train at the current time
            }
            
            // updating the firing rate and the synaptic elements
            for (int ii = 0; ii < N; ii++){
                fi[ii] += dt/Tslow * (-fi[ii] + train_post[ii]*1e3);
                delAx[ii] += dt * sprouting_rate * (1- fi[ii]/fT);
                delDn[ii] += dt * sprouting_rate * (1- fi[ii]/fT); // these two equations would have slightly different constants if used the Gaussian curve with different rates for axons and dendrities
            }
            
            // order parameter
            sumsin = 0; sumcos = 0;
            for (int ii = 0; ii < N; ii++){
                phi[ii] = 2*pi*((current_time - spikeTimes0[ii])/(spikeTimes[ii] - spikeTimes0[ii]) + counts2[ii]);
                sumcos += cos(phi[ii]); sumsin += sin(phi[ii]);
            }
            odpr += sqrt(pow((sumcos/N),2) + pow((sumsin/N),2));
            
            STDP1(N,dt,ed,ep,train_pre,train_post,trace_pre,trace_post,inlinks,Wlinks,preLinks); // updating the weights

        }
        odpr = odpr/nt; // time-averaging the order paramter

        fi_mean0 = fi_mean;
        fi_mean = 0;
        for (int ii = 0; ii < N; ii++) fi_mean += fi[ii]/N;
        fi_err = 2*abs(fi_mean-fi_mean0)/(fi_mean+fi_mean0); // relative error between current and previous network-averaged firing rates 
        
        Avg_W0 = Avg_W;
        // calculating the mean of the synaptic weights and node degree
        sum = 0; in_con = 0;
        for(int ii = 0; ii < N; ii++){
            nl = inlinks[ii]; sum_loc = 0; 
            for(int jj = 0; jj < nl; jj++) sum_loc += Wlinks[ii][jj];
            in_con += nl;
            sum += sum_loc;
            avgW[ii] = sum_loc/nl;
        }
        Avg_W = sum/in_con;
        indeg = in_con/N/(N-1);
        Avg_Werr = 2*abs(Avg_W-Avg_W0)/(Avg_W+Avg_W0); // relative error between current and previous network-averaged weight 

        // recording the firing rates every 10th iteration
        if (i % 10 == 0 && flg == 2){
            for(int ii = 0; ii < N; ii++){
                FR_file << fi[ii] << "  ";
            }
            FR_file << endl;
        }
        
        if (i > 1*msecs/Tw && fi_err < max_err && Avg_Werr < max_err && flg == 2){ // at least for the first 1 hour, there is no structural update
            flg = 0;
        }
        if ( ((fi_err < max_err && Avg_Werr < max_err) || i%30 == 0) && flg == 0){ // (Avg_Werr < max_err && fi_err < max_err)
            flg = 1;
            sp_it = i;
        } 
        if (i == sp_it+1 && flg == 1){
            ButzSP(random,Wlinks,A,Zd,fT,fi,inlinks,outlinks,Tw,sprouting_rate,Pw,pruned,added,Ax,Ax_vac,delAx,Dn,Dn_vac,delDn,preLinks,postLinks,Wmin);
            flg = 0;
            iSPupdate += 1;
            for(int ii = 0; ii < N; ii++){
                FR_file << fi[ii] << "  ";
            }
            FR_file << endl;
        }
        
        data << left << setw(15) << odpr << left << setw(15) << fi_mean << left << setw(15) << Avg_W << left << setw(15) << indeg << left << setw(15) << pruned << left << setw(15) << added << left << setw(15) << iSPupdate << endl;      
        cout << odpr << "  " << fi_mean << "   " << Avg_W << "   " << indeg << "   " << pruned << "  " << added << endl;  
        i += 1;
    }

    // recording the steady-state weights
    for(int ii = 0; ii < N; ii++){
        nl = inlinks[ii];
        for(int jj = 0; jj < nl; jj++){
            W_file << Wlinks[ii][jj] << "  ";
        }
    }

    // recording the Adjacency Matrix
    for(int ii = 0; ii < N; ii++){
        for(int jj = 0; jj < N; jj++){
            A_file << A[ii][jj] << "  ";
        }
        A_file << endl;
    }

    W_file.close();
    A_file.close();
    FR_file.close();
    data.close();
    return 0;
}


vector<vector<double> > Adjacency_Matrix(int N, double p){ //Erdos Renyi random graph
    double rnd;
    vector<double> zeros(N,0);
    vector<vector<double> > matrix(N,zeros);
    for (int i = 0; i < N; i++){
        for (int j = 0; j < N; j++){
            if(i == j) continue;
            rnd = 0.0001*(rand()%10001);
            if(rnd <= p){
                matrix[i][j] = 1;
            }
        }
    }
    return matrix;
}

vector<vector<double> > Dist_Dep_Adjacency_Matrix(int N, double p, vector<vector<double> > Zd){
    double ncon=0;
    double rnd;
    vector<double> zeros(N,0);
    vector<vector<double> > matrix(N,zeros);
    while (p-ncon/N/(N-1) > 0.001){ 
        for (int i = 0; i < N; i++){
            for (int j = 0; j < N; j++){
                rnd = 0.0001*(rand()%10001);
                if (i!=j && matrix[i][j] == 0 && rnd < p*Zd[i][j]){
                    matrix[i][j] = 1;
                    ncon += 1;
                }
            }
            if (ncon > p*N*(N-1)) break;
        }
    }        
    return matrix;
}

void InF(double dt, int itrain, double gleak[], double gsyn[], double gnoise[], double noise[], double V[], double Vth[], double Istim[], double inlinks[], double train_pre[], 
                double tdelay, double Vrest, double Vsyn, double Vth_rest, double Tsyn, double Tth, double C0, double k, double knoise, int N, 
                vector<vector<double> > &A, vector<vector<double> > &Wlinks, vector<vector<int> > &preLinks){
    
    double cpl_term;
    int nl, pre;
    for(int ii = 0; ii < N; ii++){ // updating the membrane potential and the threshold of each neuron
        V[ii] = V[ii] + dt/C0 * (gleak[ii]*(Vrest - V[ii]) + (gsyn[ii] + gnoise[ii])*(Vsyn - V[ii]) + Istim[ii]);
        Vth[ii] = Vth[ii] - dt/Tth * (Vth[ii] - Vth_rest);
    }
    for(int ii = 0; ii < N; ii++){ // updating the 'gsyn' of each neuron
        cpl_term = 0;
        nl = inlinks[ii];
        for (int jj = 0; jj < nl; jj++){ // evaluating the coupling term
            pre = preLinks[ii][jj];
            cpl_term += Wlinks[ii][jj] * train_pre[pre]; // train_pre[i] is either 0 or 1/dt
        }
        gsyn[ii] = gsyn[ii] + dt/Tsyn * (-gsyn[ii] + k*Tsyn*cpl_term/N);
    }
    for(int ii = 0; ii < N; ii++){ // updating the 'gnoise' of each neuron
        gnoise[ii] = gnoise[ii] + dt/Tsyn * (-gnoise[ii] + knoise*Tsyn*noise[ii]);
    }
     
}

void STDP1(int N, double dt, double ed, double ep, double train_pre[], double train_post[], double trace_pre[], double trace_post[], double inlinks[], vector<vector<double> > &Wlinks, vector<vector<int> > &preLinks){
    int nl,pre;
    double Wij;
    for (int ii= 0; ii< N; ii++){ // for each postsynaptic neuron
        nl = inlinks[ii];
        for (int jj = 0; jj < nl; jj++){
            pre = preLinks[ii][jj];
            Wij = Wlinks[ii][jj];
            Wij += dt*(-ed*(trace_post[ii]*train_pre[pre]) + ep*(trace_pre[pre]*train_post[ii]));
            if (Wij >= 1) Wij = 1;
            if (Wij < 0) Wij = 0;
            Wlinks[ii][jj] = Wij;
        } 
    }
}

void ButzSP(Ran &random, vector<vector<double> > &Wlinks, vector<vector<double> > &A, vector<vector<double> > Zd, double fT, double fi[], double inlinks[], double outlinks[],
             double Tw, double sprouting_rate, double Pw, int &pruned, int &added, double Ax[], double Ax_vac[], double delAx[], double Dn[],
             double Dn_vac[], double delDn[], vector<vector<int> > &preLinks, vector<vector<int> > &postLinks, double Wmin){
    
    int random_index, post_ind, pre_ind, dA, dDn, pre_loc, post_loc, sumAx_vac, sumDn_vac, max_new_con, rndi, rndj, pose, kkk, nl, xtrAx, xtrDn, pre_shift;
    int Ax_cumsum[N], Dn_cumsum[N], delAx_rounded[N], delDn_rounded[N];
    double wij;
    pruned = 0; added = 0; 

    // calculating the change in the # of axonal and dendritic elements
    for (int ii = 0; ii < N; ii++){ 
        if (delAx[ii] >= 0) delAx_rounded[ii] = floor(delAx[ii]);
        if (delDn[ii] >= 0) delDn_rounded[ii] = floor(delDn[ii]);
        if (delAx[ii] < 0) delAx_rounded[ii] = ceil(delAx[ii]);
        if (delDn[ii] < 0) delDn_rounded[ii] = ceil(delDn[ii]);
        delAx[ii] = delAx[ii] - delAx_rounded[ii]; // keeps the residue to add with the next update
        delDn[ii] = delDn[ii] - delDn_rounded[ii];
    } 
    
    // Pruning the axonal elements for the neurons that got delAx < 0
    for (int jj = 0; jj < N; jj++){
        if (delAx_rounded[jj] < 0 && Ax[jj] > 1){
            dA = abs(delAx_rounded[jj]); // number of axonal elements that need to be deleted
            for (int kk = 0; kk < dA; kk++){
                random_index = rand() % int(Ax[jj]); // Ax includes the connected and vacant axonal elements
                if (random_index >= outlinks[jj] && Ax_vac[jj] > 1){ // so that we don't prune all the axonal elements of the jj-th neuron
                    Ax_vac[jj] -= 1;
                    Ax[jj] -= 1;
                }
                if (random_index < outlinks[jj] && outlinks[jj] > 1){ // // so that we don't prune all the axonal elements of the jj-th neuron
                    post_ind = postLinks[jj][random_index]; // identifies the index of the postsynaptic neuron
                    if (inlinks[post_ind] <= 1) continue; // // so that we don't prune all the contacts of the postsynaptic partner
                    postLinks[jj].erase(postLinks[jj].begin()+random_index); // removes the postsynaptic neuron's index from the matrix
                    pre_loc = find(preLinks[post_ind].begin(),preLinks[post_ind].end(),jj) - preLinks[post_ind].begin();  // finds out the location of the presynaptic partner (jj) in the preLinks matrix
                    Wlinks[post_ind].erase(Wlinks[post_ind].begin()+pre_loc); // removes the postsynaptic neuron's weight from the jj-th neuron
                    preLinks[post_ind].erase(preLinks[post_ind].begin()+pre_loc); // removes the presynaptic neuron's index from the postsynaptic neuron's row in the matrix
                    A[post_ind][jj] -= 1;
                    Dn_vac[post_ind] += 1; // removal of axonal element leaves the corresponding dendritic element vacant
                    pruned++;
                    inlinks[post_ind] -= 1;
                    outlinks[jj] -= 1;  
                    Ax[jj] -= 1;  
                }
            }
        }
    }
    
    // Pruning the dendritic elements for the neurons that got delDn < 0
    for (int ii = 0; ii < N; ii++){
        if (delDn_rounded[ii] < 0 && Dn[ii] > 1){
            dDn = abs(delDn_rounded[ii]);
            for (int kk = 0; kk < dDn; kk++){
                random_index = rand() % int(Dn[ii]);
                if (random_index >= inlinks[ii] && Dn_vac[ii] > 1){
                    Dn_vac[ii] -= 1;
                    Dn[ii] -= 1;
                }
                if (random_index < inlinks[ii] && inlinks[ii] > 1){ // CHANGE TO 2 IF NEEDED
                    pre_ind = preLinks[ii][random_index]; // identifies the index of the presynaptic neuron
                    if (outlinks[pre_ind] <= 1) continue; // CHANGE TO 2 IF NEEDED
                    preLinks[ii].erase(preLinks[ii].begin()+random_index); // removes the presynaptic neuron's index from the matrix
                    Wlinks[ii].erase(Wlinks[ii].begin()+random_index); // removes the postsynaptic neuron's weight from the jj-th neuron
                    post_loc = find(postLinks[pre_ind].begin(),postLinks[pre_ind].end(),ii) - postLinks[pre_ind].begin();  // finds out the location of the postsynaptic partner (ii) in the postLinks matrix
                    postLinks[pre_ind].erase(postLinks[pre_ind].begin()+post_loc); // removes the postsynaptic neuron's index from the presynaptic neuron's row in the matrix
                    A[ii][pre_ind] -= 1;
                    Ax_vac[pre_ind] += 1; // removal of dendritic element leaves the corresponding axonal element vacant
                    pruned++;
                    inlinks[ii] -= 1;
                    outlinks[pre_ind] -= 1;
                    Dn[ii] -= 1;
                }
            }
        }
    }

    // weight-dependent pruning
    for (int ii = 0; ii < N; ii++){ // ii is the 'index' of postsynaptic neuron
        int jj = 0; // jj is the 'location' of presynaptic neuron in preLinks and Wlinks matrices
        while (jj < inlinks[ii]){
            if (random.doub() <  Pw*exp(-Wlinks[ii][jj]/Wmin)){
                if(inlinks[ii] <= 1 || Dn[ii] <= 1) continue;
                pre_ind = preLinks[ii][jj]; // identifies the index of the presynaptic neuron
                if (outlinks[pre_ind] <= 1 || Ax[pre_ind] <= 1) continue;
                Wlinks[ii].erase(Wlinks[ii].begin()+jj); // removes the postsynaptic neuron's weight from the jj-th neuron
                preLinks[ii].erase(preLinks[ii].begin()+jj); // removes the presynaptic neuron's index from the matrix
                post_loc = find(postLinks[pre_ind].begin(),postLinks[pre_ind].end(),ii) - postLinks[pre_ind].begin();  // finds out the location of the postsynaptic partner (ii) in the postLinks matrix
                postLinks[pre_ind].erase(postLinks[pre_ind].begin()+post_loc); // removes the postsynaptic neuron's index from the presynaptic neuron's row in the matrix
                inlinks[ii] -= 1;
                outlinks[pre_ind] -= 1;
                pruned++;
                A[ii][pre_ind] -= 1;
                Dn[ii] -= 1;
                Ax[pre_ind] -= 1; // both axonal and dendritic elements are removed when weight of the contact is responsible for its pruning
                jj -= 1; // so that we do not skip the contact next to the one that just got pruned
            }
            jj += 1;
        }
    }
    
    // Increasing the Ax and Dn values for the neurons that gained the axonal and dendritic elements
    // Note that the new axonal elements will be vacant initially
    for (int jj = 0; jj < N; jj++){
        if (delAx_rounded[jj] > 0){
            Ax[jj] += delAx_rounded[jj];
            Ax_vac[jj] += delAx_rounded[jj];
        }
        if (delDn_rounded[jj] > 0){
            Dn[jj] += delDn_rounded[jj];
            Dn_vac[jj] += delDn_rounded[jj];
        }
    }
    
    // removing the extra vacant/free synaptic elements for neurons with more than 10 of those
    // Also, calculating the total number of vacant axonal and dendritic elements
    sumAx_vac = 0; sumDn_vac = 0;
    for (int jj = 0; jj < N; jj++){
        if (Ax_vac[jj] > 10){ // there is no change in the number of vacant elements due to exponential decay (Butz2013,Eq.5) if they are < 10
            xtrAx = Ax_vac[jj] - ceil(0.904*Ax_vac[jj]);
            Ax_vac[jj] -= xtrAx; 
            Ax[jj] -= xtrAx;
        }
        if (Dn_vac[jj] > 10){
            xtrDn = Dn_vac[jj] - ceil(0.904*Dn_vac[jj]);
            Dn_vac[jj] -= xtrDn; 
            Dn[jj] -= xtrDn;
        }
        sumAx_vac += Ax_vac[jj];
        sumDn_vac += Dn_vac[jj];
    }
    max_new_con = min(sumAx_vac,sumDn_vac); // the maximum number of new contacts that may be established if the distance-dependent probability of forming contacts permits
    
    // Placing the indices of the neurons that might gain contacts in 'allAx_vac' and 'allDn_vac' 
    vector<int> allAx_vac(sumAx_vac,0);
    vector<int> allDn_vac(sumDn_vac,0);
    pose = 0;
    for(int ii = 0; ii < N; ii++){
        kkk = Ax_vac[ii]; // placing the index of neuron 'ii' 'kkk' times 
        for (int jj = 0; jj < kkk; jj++){
            allAx_vac[pose+jj] = ii;
        }
        pose += kkk;
    }
    pose = 0;
    for(int ii = 0; ii < N; ii++){
        kkk = Dn_vac[ii];
        for (int jj = 0; jj < kkk; jj++){
            allDn_vac[pose+jj] = ii;
        }
        pose += kkk;
    }
    shuffle(allAx_vac.begin(),allAx_vac.end(),default_random_engine(0)); // this shuffling will allow a simple implementation of randomly choosing partners
    shuffle(allDn_vac.begin(),allDn_vac.end(),default_random_engine(10));
    
    // Adding new contacts
    for (int ii = 0; ii < max_new_con; ii++){
        pre_ind = allAx_vac[ii];
        post_ind = allDn_vac[ii];
        // if(the distance-dep prob permits)
        if (pre_ind != post_ind && A[post_ind][pre_ind] < 10 && random.doub() < Zd[post_ind][pre_ind]){ // allowing a maximum of 10 contacts between a pair of neurons
            Dn_vac[post_ind] -= 1;
            Ax_vac[pre_ind] -= 1;
            A[post_ind][pre_ind] += 1;
            inlinks[post_ind] += 1;
            outlinks[pre_ind] += 1;
            preLinks[post_ind].insert(preLinks[post_ind].begin(),pre_ind);
            postLinks[pre_ind].insert(postLinks[pre_ind].begin(),post_ind);
            Wlinks[post_ind].insert(Wlinks[post_ind].begin(),0.2*random.doub());
            added++;
        }
    }
}
